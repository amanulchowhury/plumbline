import PlumblineAdapter from './PlumblineAdapter';
import {DebugElement} from '@angular/core';
import {By} from '@angular/platform-browser';
import Rendering from './models/Rendering';

export class ShallowWrapper<T>
{
    private renderer: any = null;
    private renderPromise: Promise<Rendering> = null;
    private rendering: Rendering = null;
    private currentElement: DebugElement = null;


    constructor() {
        // Generate a renderer for shallow operation
        this.renderer = (new PlumblineAdapter()).createRenderer({mode: 'shallow'});
    }

    /**
     * Create ShallowWrapper
     * @param nodes
     * @param testComponent
     * @param testModule
     * @param options
     * @returns {ShallowWrapper<T>}
     */
    create(nodes: any, testComponent: T, testModule: any, options: any): ShallowWrapper<T> {
        this.renderPromise = this.renderer.render(
            nodes,
            options ? options : {},
            testComponent,
            testModule ? testModule : {});
        return this;
    }

    private existing(unrendering: Promise<Rendering>,
                     rendering: Rendering,
                     current: DebugElement): ShallowWrapper<T> {
        this.renderPromise = unrendering;
        this.rendering = rendering;
        this.currentElement = current;
        return this;
    }

    /**
     * Render the Component
     * @returns {Promise<ShallowWrapper<T>>}
     */
    async render(): Promise<ShallowWrapper<T>> {
        return new Promise<ShallowWrapper<T>>((resolve: any, reject: any) => {
            this.renderPromise.then((rendering) => {
                this.rendering = rendering;
                this.currentElement = this.rendering.element;
                this.renderPromise = null;
                resolve(this);
            });
        });
    }

    private checkRender(): void {
        if (this.rendering == null) {
            throw new Error('Use render() and await on ShallowWrapper ' +
                'to complete the rendering process.');
        }
    }


    /**
     * Get ElementRef of ShallowWrapper
     * @return ElementRef of current ShallowWrapper
     */
    element(): any {
        this.checkRender();
        return this.currentElement.nativeNode;
    }

    /**
     * Find child element within ShallowWrapper
     * @return child elements matched
     */
    find(cssOrDirective: any): Array<ShallowWrapper<T>> {
        this.checkRender();
        let query = null;
        if (typeof cssOrDirective === 'string') {
            query = By.css(cssOrDirective);
        } else {
            query = By.directive(cssOrDirective);
        }

        let matches = this.currentElement.queryAll(query);
        if (matches.length && matches[0] === this.currentElement) {
            throw new Error(`Don't use 'find' to search for your test component, ` +
                `it is automatically returned by the shallow renderer`);
        }

        let wrapperArray: Array<ShallowWrapper<T>> = [];
        matches.forEach((elem) => {
            wrapperArray.push((new ShallowWrapper<T>()).existing(this.renderPromise,
                this.rendering, elem));
        });
        return wrapperArray;
    }

    /**
     * Find parent element of ShallowWrapper
     * @return parent of ShallowWrapper
     */
    parent(): ShallowWrapper<T> {
        return (new ShallowWrapper<T>()).existing(this.renderPromise,
            this.rendering, this.currentElement.parent);
    }

    /**
     * Get the instance of this Component in TestBed
     * @returns instance of Component in TestBed
     */
    instance(): T {
        this.checkRender();
        return this.rendering.instance;
    }

    /**
     * Get the bindings that were used in this Component instance
     * @returns bindings used to create this Component
     */
    bindings(): any {
        this.checkRender();
        return this.rendering.bindings;
    }

    /**
     * Get the fixture generated by TestBed
     * @returns fixture for Component generated by TestBed
     */
    fixture(): any {
        this.checkRender();
        return this.rendering.fixture;
    }

    /**
     * Wait for the instance and DOM to update
     */
    update(): void {
        this.checkRender();
        this.rendering.instance.ngOnChanges();
        this.rendering.fixture.detectChanges();
        // return this.rendering.fixture.whenStable();
    }

    tester(): any {
        return this.rendering.tester;
    }

    /**
     * Get the module used in this Component instance test
     * @returns complete module put together by ShallowWrapper
     */
    module(): any {
        return this.rendering.tester.completeModule;
    }
}
